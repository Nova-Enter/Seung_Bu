<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>도면 자동 색칠 앱</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root { --primary-color: #4f46e5; --primary-hover: #4338ca; --active-color: #10b981; }
        html, body { height: 100%; margin: 0; overflow: hidden; }
        body { font-family: 'Inter', sans-serif; background-color: #f0f2f5; }
        .app-container { height: 100%; }
        .btn { padding: 6px 12px; font-size: 13px; border-radius: 6px; font-weight: 500; transition: all 0.2s ease-in-out; cursor: pointer; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); border: none; }
        .btn:disabled { background-color: #e5e7eb !important; color: #9ca3af !important; cursor: not-allowed; transform: none; box-shadow: none; border-color: #d1d5db; }
        .btn-primary { background-color: var(--primary-color); color: white; }
        .btn-primary:not(:disabled):hover { background-color: var(--primary-hover); transform: translateY(-1px); }
        .btn-secondary { background-color: #ffffff; color: #374151; border: 1px solid #d1d5db; }
        .btn-secondary:not(:disabled):hover { background-color: #f9fafb; }
        .tool-active { border: 2px solid var(--active-color) !important; box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.3) !important; }
        .color-swatch { width: 22px; height: 22px; border-radius: 6px; cursor: pointer; border: 2px solid transparent; transition: all 0.2s ease-in-out; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
        .color-swatch:hover { transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15); }
        .color-swatch.selected-swatch { border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.3); }
        .message-box { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: #333; color: white; padding: 10px 20px; border-radius: 8px; z-index: 1000; opacity: 0; visibility: hidden; transition: all 0.3s ease-in-out; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); font-size: 14px; }
        .message-box.show { opacity: 1; visibility: visible; bottom: 30px; }
        .canvas-container { cursor: default; }
        #pdfPageSelector, #contextMenu { z-index: 2000; }
        #contextMenu {
            position: fixed;
            display: none;
            background-color: white;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            padding: 8px;
            min-width: 150px;
        }
        #contextMenu button {
            display: block;
            width: 100%;
            text-align: left;
            padding: 8px 12px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
        }
        #contextMenu button:hover {
            background-color: #f3f4f6;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="app-container bg-white rounded-xl shadow-xl p-3 m-2 flex flex-col gap-2 max-h-[calc(100vh-1rem)]">
        <h1 class="text-lg font-bold text-center text-gray-800 flex-shrink-0">도면 자동 색칠 앱</h1>
        
        <div class="flex-shrink-0 border-b border-gray-200 pb-2 space-y-2">
            <div class="flex flex-wrap gap-x-3 gap-y-2 justify-center items-center">
                <button id="uploadBtn" class="btn btn-primary">이미지/PDF</button>
                <input type="file" id="fileInput" accept="image/png, image/jpeg, application/pdf" class="hidden" />
                <div class="w-px bg-gray-300 h-6 mx-1"></div>
                <button id="selectLayerBtn" class="btn btn-secondary">레이어 선택</button>
                <button id="smartFillBtn" class="btn btn-secondary">스마트 채우기</button>
                <button id="rectSelectBtn" class="btn btn-secondary">영역 선택</button>
                <button id="polySelectBtn" class="btn btn-secondary">직선 선택</button>
                <button id="cropBtn" class="btn btn-secondary">자르기</button>
                <div class="w-px bg-gray-300 h-6 mx-1"></div>
                <button id="applyCropBtn" class="btn btn-primary">자르기 실행</button>
                <button id="clearSelectionBtn" class="btn btn-secondary">선택 해제</button>
            </div>
            <div class="flex flex-wrap gap-x-3 gap-y-2 justify-center items-center">
                 <div class="flex items-center gap-1">
                    <label for="colorPicker" class="text-xs font-medium text-gray-600">색상:</label>
                    <input type="color" id="colorPicker" value="#4f46e5" class="w-7 h-7 border-none rounded-md cursor-pointer p-0 overflow-hidden" />
                </div>
                <div id="swatchContainer" class="flex items-center gap-1.5"></div>
                <div class="w-px bg-gray-300 h-6 mx-1"></div>
                <div class="flex items-center gap-1">
                    <label for="opacitySlider" class="text-xs font-medium text-gray-600">투명도:</label>
                    <input type="range" id="opacitySlider" min="0" max="1" step="0.01" value="1" class="w-20" />
                </div>
                <div class="flex items-center gap-1">
                    <label for="lineWidthSlider" class="text-xs font-medium text-gray-600">선굵기:</label>
                    <input type="range" id="lineWidthSlider" min="1" max="10" step="0.5" value="1" class="w-20" />
                </div>
                <div class="flex items-center gap-1">
                    <label for="featherSlider" class="text-xs font-medium text-gray-600">페더:</label>
                    <input type="range" id="featherSlider" min="0" max="20" step="0.5" value="0" class="w-20" />
                </div>
                <div class="flex items-center gap-1">
                    <label for="blendModeSelect" class="text-xs font-medium text-gray-600">블렌딩:</label>
                    <select id="blendModeSelect" class="p-1 border border-gray-300 rounded-md shadow-sm text-xs focus:ring-indigo-500 focus:border-indigo-500">
                        <option value="source-over">표준</option>
                        <option value="multiply">곱하기</option>
                        <option value="difference">빼기</option>
                    </select>
                </div>
                <div class="w-px bg-gray-300 h-6 mx-1"></div>
                <button id="rotateLeftBtn" class="btn btn-secondary">왼쪽 회전</button>
                <button id="rotateRightBtn" class="btn btn-secondary">오른쪽 회전</button>
                <button id="undoBtn" class="btn btn-secondary">실행취소</button>
                <button id="resetBtn" class="btn btn-secondary">초기화</button>
                <div class="w-px bg-gray-300 h-6 mx-1"></div>
                <button id="downloadPngBtn" class="btn btn-primary">PNG</button>
                <button id="downloadJpgBtn" class="btn btn-primary">JPG</button>
                <button id="downloadPdfBtn" class="btn btn-primary">PDF</button>
            </div>
        </div>

        <div id="canvasContainer" class="relative w-full flex-1 bg-gray-100 rounded-lg grid place-items-center overflow-auto min-h-0 p-2">
            <p id="noImageText" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-gray-500 text-lg">이미지/PDF 파일을 업로드하여 시작하세요.</p>
            <div id="canvasSizer" style="position: relative; flex-shrink: 0;">
                <canvas id="drawingCanvas" style="z-index: 1; position: absolute; top: 0; left: 0;"></canvas>
                <canvas id="selectionCanvas" class="absolute" style="z-index: 2; top: 0; left: 0;"></canvas>
            </div>
        </div>

        <div id="messageBox" class="message-box"></div>
        
        <div id="pdfPageSelector" class="hidden fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center">
            <div class="bg-white rounded-lg p-6 max-w-4xl max-h-[80vh] overflow-y-auto">
                <h2 class="text-xl font-bold mb-4">페이지 선택</h2>
                <div id="pdfPageContainer" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4"></div>
            </div>
        </div>

        <div id="contextMenu">
            <button id="contextDownloadPng">PNG로 저장</button>
            <button id="contextDownloadJpg">JPG로 저장</button>
            <button id="contextDownloadPdf">PDF로 저장</button>
        </div>
    </div>

    <script>
        if (window.pdfjsLib) {
            pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js`;
        }
        
        window.addEventListener('DOMContentLoaded', () => {
            // Element selectors
            const uploadBtn = document.getElementById('uploadBtn');
            const fileInput = document.getElementById('fileInput');
            const drawingCanvas = document.getElementById('drawingCanvas');
            const selectionCanvas = document.getElementById('selectionCanvas');
            const canvasContainer = document.getElementById('canvasContainer');
            const canvasSizer = document.getElementById('canvasSizer');
            const noImageText = document.getElementById('noImageText');
            const messageBox = document.getElementById('messageBox');
            const selectLayerBtn = document.getElementById('selectLayerBtn');
            const smartFillBtn = document.getElementById('smartFillBtn');
            const rectSelectBtn = document.getElementById('rectSelectBtn');
            const polySelectBtn = document.getElementById('polySelectBtn');
            const cropBtn = document.getElementById('cropBtn');
            const applyCropBtn = document.getElementById('applyCropBtn');
            const clearSelectionBtn = document.getElementById('clearSelectionBtn');
            const colorPicker = document.getElementById('colorPicker');
            const swatchContainer = document.getElementById('swatchContainer');
            const opacitySlider = document.getElementById('opacitySlider');
            const lineWidthSlider = document.getElementById('lineWidthSlider');
            const featherSlider = document.getElementById('featherSlider');
            const blendModeSelect = document.getElementById('blendModeSelect');
            const rotateLeftBtn = document.getElementById('rotateLeftBtn');
            const rotateRightBtn = document.getElementById('rotateRightBtn');
            const undoBtn = document.getElementById('undoBtn');
            const resetBtn = document.getElementById('resetBtn');
            const downloadPngBtn = document.getElementById('downloadPngBtn');
            const downloadJpgBtn = document.getElementById('downloadJpgBtn');
            const downloadPdfBtn = document.getElementById('downloadPdfBtn');
            const pdfPageSelector = document.getElementById('pdfPageSelector');
            const pdfPageContainer = document.getElementById('pdfPageContainer');
            const contextMenu = document.getElementById('contextMenu');
            const contextDownloadPng = document.getElementById('contextDownloadPng');
            const contextDownloadJpg = document.getElementById('contextDownloadJpg');
            const contextDownloadPdf = document.getElementById('contextDownloadPdf');

            // Canvas contexts
            const drawingCtx = drawingCanvas.getContext('2d');
            const selectionCtx = selectionCanvas.getContext('2d');

            // State variables
            let initialUploadImage = null;
            let originalImage = null;
            let layers = [];
            let history = [];
            let historyPointer = -1;
            const MAX_HISTORY_STEPS = 20;
            let activeTool = null;
            let activeLayerIds = [];
            let isDrawing = false; // For rectangular select and crop
            let isPolygonDrawing = false; // For polygon select
            let startPos = { x: 0, y: 0 };
            let lastClientPos = { x: 0, y: 0 };
            let animationFrameId;
            let selectionRect = null;
            let polygonPoints = [];
            let cropRect = null;
            let scale = 1;
            const predefinedSwatchColors = ['#FF0000', '#FFA500', '#FFFF00', '#008000', '#0000FF', '#800080', '#000000', '#FFFFFF', '#808080', '#FFC0CB', '#A52A2A', '#87CEEB'];
            let dashOffset = 0;
            let antsInterval = null;
            
            // Zoom and Pan state
            let pinchStartDistance = null;
            let lastScale = 1;
            let lastTapTime = 0;

            // Polygon tool improvements
            let polygonPreviewEndPoint = null;

            function hexToRgb(hex) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return { r, g, b };
            }

            function showMessage(text, duration = 3000) {
                messageBox.textContent = text;
                messageBox.classList.add('show');
                setTimeout(() => { messageBox.classList.remove('show'); }, duration);
            }

            function updateButtonStates() {
                const hasImage = !!originalImage;
                const hasSelection = !!selectionRect;
                const hasCrop = !!cropRect;

                [selectLayerBtn, smartFillBtn, rectSelectBtn, polySelectBtn, cropBtn, resetBtn, downloadPngBtn, downloadJpgBtn, downloadPdfBtn, rotateLeftBtn, rotateRightBtn].forEach(btn => btn.disabled = !hasImage);
                selectLayerBtn.disabled = !hasImage || layers.length === 0;
                applyCropBtn.disabled = !hasCrop;
                clearSelectionBtn.disabled = !hasSelection && !hasCrop && polygonPoints.length === 0 && activeLayerIds.length === 0;
                undoBtn.disabled = historyPointer <= 0;
                const isSelectionToolActive = ['rectangularSelect', 'polygonLassoSelect', 'crop'].includes(activeTool);
                lineWidthSlider.disabled = !isSelectionToolActive;
                featherSlider.disabled = activeLayerIds.length === 0;
                
                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('tool-active'));
                if (activeTool) {
                    const activeBtn = document.getElementById({
                        'selectLayer': 'selectLayerBtn', 'smartFill': 'smartFillBtn',
                        'rectangularSelect': 'rectSelectBtn', 'polygonLassoSelect': 'polySelectBtn', 'crop': 'cropBtn'
                    }[activeTool]);
                    if(activeBtn) activeBtn.classList.add('tool-active');
                }
                
                let cursor = 'default';
                if(activeTool) {
                    if(activeTool === 'selectLayer' || activeTool === 'smartFill') cursor = 'pointer';
                    else cursor = 'crosshair';
                }
                canvasContainer.style.cursor = cursor;
            }
            
            function createSwatches() {
                predefinedSwatchColors.forEach(hex => {
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch';
                    swatch.style.backgroundColor = hex;
                    swatch.dataset.color = hex;
                    swatch.addEventListener('click', () => {
                        colorPicker.value = hex;
                        handleColorPickerInput();
                    });
                    swatchContainer.appendChild(swatch);
                });
                updateSwatches();
            }

            function updateSwatches() {
                document.querySelectorAll('.color-swatch').forEach(swatch => {
                    swatch.classList.toggle('selected-swatch', swatch.dataset.color.toUpperCase() === colorPicker.value.toUpperCase());
                });
            }

            function saveState() {
                const currentState = {
                    layers: JSON.parse(JSON.stringify(layers)),
                    imageSrc: originalImage.src
                };
                history = history.slice(0, historyPointer + 1);
                history.push(currentState);
                if (history.length > MAX_HISTORY_STEPS) history.shift();
                historyPointer = history.length - 1;
                updateButtonStates();
            }

            function undo() {
                if (historyPointer > 0) {
                    historyPointer--;
                    const prevState = history[historyPointer];
                    layers = JSON.parse(JSON.stringify(prevState.layers));
                    
                    if (originalImage.src !== prevState.imageSrc) {
                        const img = new Image();
                        img.onload = () => {
                            originalImage = img;
                            scale = canvasContainer.clientWidth / originalImage.width;
                            renderAll();
                            updateButtonStates();
                        }
                        img.src = prevState.imageSrc;
                    } else {
                        renderAll();
                        updateButtonStates();
                    }
                    
                    activeLayerIds = [];
                    showMessage('실행 취소되었습니다.');
                } else {
                    showMessage('더 이상 실행 취소할 작업이 없습니다.');
                }
            }
            
            function clearAllSelections() {
                selectionRect = null;
                polygonPoints = [];
                isPolygonDrawing = false;
                cropRect = null;
                activeLayerIds = [];
                polygonPreviewEndPoint = null; // Clear preview line
                renderSelectionCanvas();
                updateButtonStates();
            }

            function renderAll() {
                renderDrawingCanvas();
                renderSelectionCanvas();
                handleResize();
            }

            function renderDrawingCanvas() {
                if (!originalImage) return;
                
                drawingCanvas.width = originalImage.width;
                drawingCanvas.height = originalImage.height;
                drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                drawingCtx.drawImage(originalImage, 0, 0);

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = drawingCanvas.width;
                tempCanvas.height = drawingCanvas.height;
                const tempCtx = tempCanvas.getContext('2d');

                layers.forEach(layer => {
                    tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                    tempCtx.fillStyle = layer.color;
                    layer.pixels.forEach(p => {
                        tempCtx.fillRect(p.x, p.y, 1, 1);
                    });

                    drawingCtx.globalAlpha = layer.opacity;
                    drawingCtx.globalCompositeOperation = layer.blendMode || 'source-over';
                    drawingCtx.filter = `blur(${layer.feather || 0}px)`;
                    drawingCtx.drawImage(tempCanvas, 0, 0);
                });
                
                drawingCtx.filter = 'none';
                drawingCtx.globalAlpha = 1.0;
                drawingCtx.globalCompositeOperation = 'source-over';
            }

            function renderSelectionCanvas() {
                if (!originalImage) return;
                selectionCanvas.width = originalImage.width;
                selectionCanvas.height = originalImage.height;
                selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);

                // Selected layer outline (Marching Ants)
                if (activeLayerIds.length > 0) {
                    if (!antsInterval) startMarchingAnts();
                    selectionCtx.strokeStyle = '#000';
                    selectionCtx.lineWidth = 1 / scale;
                    selectionCtx.setLineDash([4, 4]);
                    selectionCtx.lineDashOffset = -dashOffset;
                    
                    selectionCtx.beginPath();
                    activeLayerIds.forEach(id => {
                        const activeLayer = layers.find(l => l.id === id);
                        if (activeLayer) {
                           const allPixels = new Set(activeLayer.pixels.map(p => `${p.x},${p.y}`));
                           allPixels.forEach(pStr => {
                               const [x, y] = pStr.split(',').map(Number);
                               if (!allPixels.has(`${x},${y-1}`)) { selectionCtx.moveTo(x, y); selectionCtx.lineTo(x + 1, y); }
                               if (!allPixels.has(`${x+1},${y}`)) { selectionCtx.moveTo(x + 1, y); selectionCtx.lineTo(x + 1, y + 1); }
                               if (!allPixels.has(`${x},${y+1}`)) { selectionCtx.moveTo(x + 1, y + 1); selectionCtx.lineTo(x, y + 1); }
                               if (!allPixels.has(`${x-1},${y}`)) { selectionCtx.moveTo(x, y + 1); selectionCtx.lineTo(x, y); }
                           });
                        }
                    });
                    selectionCtx.stroke();
                } else {
                    stopMarchingAnts();
                }

                // Rectangular selection
                if (selectionRect) {
                    selectionCtx.strokeStyle = '#4f46e5';
                    selectionCtx.lineWidth = lineWidthSlider.value / scale;
                    selectionCtx.setLineDash([5, 5]);
                    selectionCtx.strokeRect(selectionRect.x, selectionRect.y, selectionRect.width, selectionRect.height);
                }

                // Polygon selection (committed lines)
                if (polygonPoints.length > 0) {
                    selectionCtx.strokeStyle = '#4f46e5';
                    selectionCtx.lineWidth = lineWidthSlider.value / scale;
                    selectionCtx.setLineDash([]);
                    selectionCtx.beginPath();
                    selectionCtx.moveTo(polygonPoints[0].x, polygonPoints[0].y);
                    for (let i = 1; i < polygonPoints.length; i++) selectionCtx.lineTo(polygonPoints[i].x, polygonPoints[i].y);
                    selectionCtx.stroke();
                }

                // Polygon selection preview line
                if (polygonPreviewEndPoint && polygonPoints.length > 0) {
                    selectionCtx.strokeStyle = '#4f46e5';
                    selectionCtx.lineWidth = lineWidthSlider.value / scale;
                    selectionCtx.setLineDash([3, 3]);
                    selectionCtx.beginPath();
                    const lastPoint = polygonPoints[polygonPoints.length - 1];
                    selectionCtx.moveTo(lastPoint.x, lastPoint.y);
                    selectionCtx.lineTo(polygonPreviewEndPoint.x, polygonPreviewEndPoint.y);
                    selectionCtx.stroke();
                }
                
                // Crop selection
                if (cropRect) {
                    selectionCtx.strokeStyle = '#10b981';
                    selectionCtx.lineWidth = lineWidthSlider.value / scale;
                    selectionCtx.setLineDash([5, 5]);
                    selectionCtx.strokeRect(cropRect.x, cropRect.y, cropRect.width, cropRect.height);
                }
                selectionCtx.setLineDash([]);
            }
            
            function handleResize() {
                if (!originalImage || !canvasContainer) return;
                const newCanvasWidth = originalImage.width * scale;
                const newCanvasHeight = originalImage.height * scale;
                
                canvasSizer.style.width = `${newCanvasWidth}px`;
                canvasSizer.style.height = `${newCanvasHeight}px`;

                drawingCanvas.style.width = `100%`;
                drawingCanvas.style.height = `100%`;
                selectionCanvas.style.width = `100%`;
                selectionCanvas.style.height = `100%`;

                renderSelectionCanvas(); // Redraw selection lines with correct thickness on zoom
            }

            function handleFileChange(event) {
                const file = event.target.files[0];
                if (!file) return;
                layers = [];
                activeLayerIds = [];
                if (file.type === "application/pdf" && window.pdfjsLib) handlePdfFile(file);
                else if (file.type.startsWith("image/")) handleImageFile(file);
                else showMessage("지원하지 않는 파일 형식입니다. (PNG, JPG, PDF만 가능)");
                event.target.value = null;
            }

            function handleImageFile(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        initialUploadImage = img;
                        originalImage = img;
                        noImageText.style.display = 'none';
                        scale = Math.min(canvasContainer.clientWidth / originalImage.width, canvasContainer.clientHeight / originalImage.height, 1);
                        renderAll();
                        saveState();
                        updateButtonStates();
                        showMessage('이미지가 성공적으로 업로드되었습니다!');
                    };
                    img.onerror = () => showMessage('이미지를 로드할 수 없습니다.');
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            async function handlePdfFile(file) {
                showMessage("PDF 파일을 변환 중입니다...", 5000);
                const fileReader = new FileReader();
                fileReader.onload = async function() {
                    const typedarray = new Uint8Array(this.result);
                    try {
                        const pdf = await pdfjsLib.getDocument(typedarray).promise;
                        if (pdf.numPages === 1) {
                            const page = await pdf.getPage(1);
                            renderPdfPage(page);
                        } else {
                            showPdfPageSelector(pdf);
                        }
                    } catch (error) {
                        console.error("PDF 처리 오류:", error);
                        showMessage("PDF 파일을 처리하는 중 오류가 발생했습니다.");
                    }
                };
                fileReader.readAsArrayBuffer(file);
            }
            
            async function showPdfPageSelector(pdf) {
                pdfPageContainer.innerHTML = '';
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const viewport = page.getViewport({ scale: 0.3 });
                    const canvas = document.createElement('canvas');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    const ctx = canvas.getContext('2d');
                    await page.render({ canvasContext: ctx, viewport: viewport }).promise;
                    
                    const pageDiv = document.createElement('div');
                    pageDiv.className = 'p-2 border rounded-md cursor-pointer hover:bg-gray-100';
                    pageDiv.appendChild(canvas);
                    pageDiv.addEventListener('click', () => {
                        renderPdfPage(page);
                        pdfPageSelector.classList.add('hidden');
                    });
                    pdfPageContainer.appendChild(pageDiv);
                }
                pdfPageSelector.classList.remove('hidden');
            }

            async function renderPdfPage(page) {
                const viewport = page.getViewport({ scale: 2.0 });
                const tempCanvas = document.createElement('canvas');
                tempCanvas.height = viewport.height;
                tempCanvas.width = viewport.width;
                const tempCtx = tempCanvas.getContext('2d');
                await page.render({ canvasContext: tempCtx, viewport: viewport }).promise;
                
                const img = new Image();
                img.onload = () => {
                    initialUploadImage = img;
                    originalImage = img;
                    noImageText.style.display = 'none';
                    scale = Math.min(canvasContainer.clientWidth / originalImage.width, canvasContainer.clientHeight / originalImage.height, 1);
                    renderAll();
                    saveState();
                    updateButtonStates();
                    showMessage('PDF 페이지를 불러왔습니다!');
                };
                img.src = tempCanvas.toDataURL();
            }

            function activateTool(toolName) {
                if (!originalImage) return;
                if (activeTool === toolName) return; 

                activeTool = toolName;
                clearAllSelections();

                const messages = {
                    smartFill: '캔버스를 클릭하여 색칠할 영역을 선택하세요.',
                    rectangularSelect: '드래그하여 영역을 지정하면 자동으로 채워집니다.',
                    polygonLassoSelect: '클릭으로 점을 추가하고, 더블클릭으로 도형을 완성하세요.',
                    crop: '이미지에서 자를 영역을 드래그하세요.',
                    selectLayer: '영역을 클릭하여 선택하세요. Shift 키로 다중 선택이 가능합니다.'
                };
                showMessage(messages[toolName]);
                if (toolName === 'polygonLassoSelect') {
                    isPolygonDrawing = true;
                }
                updateButtonStates();
            }
            
            function addNewLayer(pixelsToFill) {
                if (pixelsToFill.length === 0) return;

                const newPixelSet = new Set(pixelsToFill.map(p => `${p.x},${p.y}`));

                layers = layers.map(layer => {
                    const remainingPixels = layer.pixels.filter(p => !newPixelSet.has(`${p.x},${p.y}`));
                    if (remainingPixels.length === 0) return null;
                    return { ...layer, pixels: remainingPixels };
                }).filter(Boolean);

                const newLayer = {
                    id: Date.now() + Math.random(),
                    pixels: pixelsToFill,
                    color: colorPicker.value,
                    opacity: parseFloat(opacitySlider.value),
                    blendMode: blendModeSelect.value,
                    feather: parseFloat(featherSlider.value)
                };
                layers.push(newLayer);
                activeLayerIds = [newLayer.id];
                renderAll();
                saveState();
            }
            
            function getMousePos(e) {
                const rect = selectionCanvas.getBoundingClientRect();
                const scaleX = selectionCanvas.width / rect.width;
                const scaleY = selectionCanvas.height / rect.height;
                const clientX = e.clientX ?? (e.touches ? e.touches[0].clientX : 0);
                const clientY = e.clientY ?? (e.touches ? e.touches[0].clientY : 0);
                return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
            }

            function closeAndFillPolygon() {
                if (polygonPoints.length < 3) {
                    polygonPoints = [];
                    polygonPreviewEndPoint = null;
                    renderSelectionCanvas();
                    showMessage("도형을 완성하려면 3개 이상의 점이 필요합니다.", 2000);
                    return;
                }

                const pixelsInPolygon = [];
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                polygonPoints.forEach(p => {
                    minX = Math.min(minX, p.x); minY = Math.min(minY, p.y);
                    maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y);
                });
                for (let y = Math.floor(minY); y <= Math.ceil(maxY); y++) {
                    for (let x = Math.floor(minX); x <= Math.ceil(maxX); x++) {
                        let inside = false;
                        for (let i = 0, j = polygonPoints.length - 1; i < polygonPoints.length; j = i++) {
                            const xi = polygonPoints[i].x, yi = polygonPoints[i].y;
                            const xj = polygonPoints[j].x, yj = polygonPoints[j].y;
                            const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                            if (intersect) inside = !inside;
                        }
                        if (inside) pixelsInPolygon.push({ x, y });
                    }
                }
                addNewLayer(pixelsInPolygon);
                
                polygonPoints = [];
                polygonPreviewEndPoint = null;
                renderSelectionCanvas();
                updateButtonStates();
                showMessage('영역이 채워졌습니다. 계속해서 다음 영역을 선택하세요.');
            }

            function handleDrawStart(e) {
                if (e.touches && (e.touches.length > 1 || activeTool === null)) return;
                if (e.touches) {
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTapTime;
                    lastTapTime = currentTime;
                    if (tapLength < 300 && tapLength > 0) { // Double tap
                        if (activeTool === 'polygonLassoSelect' && isPolygonDrawing && polygonPoints.length > 1) {
                            e.preventDefault();
                            polygonPoints.pop(); // Remove the point added by the first tap of the double-tap
                            closeAndFillPolygon();
                        }
                        return; 
                    }
                }

                if (!originalImage || !activeTool) return;
                
                if (activeTool === 'smartFill') {
                    const pos = getMousePos(e);
                    handleSmartFill(pos);
                } else if (activeTool === 'selectLayer') {
                    const pos = getMousePos(e);
                    const x = Math.round(pos.x);
                    const y = Math.round(pos.y);
                    const coordinateString = `${x},${y}`;
                    let clickedLayer = null;
                    for (let i = layers.length - 1; i >= 0; i--) {
                        const layer = layers[i];
                        const pixelSet = new Set(layer.pixels.map(p => `${p.x},${p.y}`));
                        if (pixelSet.has(coordinateString)) {
                            clickedLayer = layer;
                            break;
                        }
                    }

                    if (e.shiftKey) {
                        if (clickedLayer) {
                            const index = activeLayerIds.indexOf(clickedLayer.id);
                            if (index > -1) {
                                activeLayerIds.splice(index, 1);
                            } else {
                                activeLayerIds.push(clickedLayer.id);
                            }
                        }
                    } else {
                        if (clickedLayer) {
                            activeLayerIds = [clickedLayer.id];
                            opacitySlider.value = clickedLayer.opacity;
                            colorPicker.value = clickedLayer.color;
                            blendModeSelect.value = clickedLayer.blendMode || 'source-over';
                            featherSlider.value = clickedLayer.feather || 0;
                            updateSwatches();
                        } else {
                            activeLayerIds = [];
                        }
                    }
                    renderSelectionCanvas();
                    updateButtonStates();

                } else if (['rectangularSelect', 'crop'].includes(activeTool)) {
                    isDrawing = true;
                    startPos = getMousePos(e);
                    lastClientPos = { x: e.clientX ?? e.touches[0].clientX, y: e.clientY ?? e.touches[0].clientY };
                    startSelectionLoop();
                } else if (activeTool === 'polygonLassoSelect' && isPolygonDrawing) {
                    const pos = polygonPreviewEndPoint || getMousePos(e);
                    
                    if (polygonPoints.length > 0) {
                        const firstPoint = polygonPoints[0];
                        const distance = Math.hypot(pos.x - firstPoint.x, pos.y - firstPoint.y);
                        if (distance < 10 / scale) { 
                            closeAndFillPolygon();
                            return;
                        }
                    }
                    polygonPoints.push(pos);
                    polygonPreviewEndPoint = null;
                    renderSelectionCanvas();
                    updateButtonStates();
                }
            }
            
            function handleSmartFill(pos) {
                if (!initialUploadImage) return;
                const originalCanvas = document.createElement('canvas');
                originalCanvas.width = drawingCanvas.width;
                originalCanvas.height = drawingCanvas.height;
                const originalCtx = originalCanvas.getContext('2d');
                originalCtx.drawImage(initialUploadImage, 0, 0);
                const originalPixels = originalCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height).data;
                const width = drawingCanvas.width, height = drawingCanvas.height;
                const startX = Math.round(pos.x), startY = Math.round(pos.y);
                const startNode = (startY * width + startX) * 4;
                const targetColor = { r: originalPixels[startNode], g: originalPixels[startNode + 1], b: originalPixels[startNode + 2] };
                const tolerance = 32;
                const queue = [{ x: startX, y: startY }];
                const visited = new Uint8Array(width * height);
                const pixelsToFill = [];
                while (queue.length > 0) {
                    const { x, y } = queue.shift();
                    const currentIndex = y * width + x;
                    if (x < 0 || x >= width || y < 0 || y >= height || visited[currentIndex]) continue;
                    visited[currentIndex] = 1;
                    const dataIndex = currentIndex * 4;
                    const currentColor = { r: originalPixels[dataIndex], g: originalPixels[dataIndex + 1], b: originalPixels[dataIndex + 2] };
                    const distance = Math.hypot(currentColor.r - targetColor.r, currentColor.g - targetColor.g, currentColor.b - targetColor.b);
                    if (distance <= tolerance) {
                        pixelsToFill.push({ x: Math.round(x), y: Math.round(y) });
                        queue.push({ x: x - 1, y: y }, { x: x + 1, y: y }, { x: x, y: y - 1 }, { x: x, y: y + 1 });
                    }
                }
                addNewLayer(pixelsToFill);
            }
            
            function handleApplyCrop() {
                if (!cropRect || cropRect.width <= 0 || cropRect.height <= 0) return;
                
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = drawingCanvas.width;
                tempCanvas.height = drawingCanvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(originalImage, 0, 0);
                layers.forEach(layer => {
                    const layerCanvas = document.createElement('canvas');
                    layerCanvas.width = tempCanvas.width;
                    layerCanvas.height = tempCanvas.height;
                    const layerCtx = layerCanvas.getContext('2d');
                    layerCtx.fillStyle = layer.color;
                    layer.pixels.forEach(p => { layerCtx.fillRect(p.x, p.y, 1, 1); });
                    
                    tempCtx.globalAlpha = layer.opacity;
                    tempCtx.globalCompositeOperation = layer.blendMode || 'source-over';
                    tempCtx.drawImage(layerCanvas, 0, 0);
                });
                tempCtx.globalAlpha = 1.0;
                tempCtx.globalCompositeOperation = 'source-over';

                const sx = Math.max(0, cropRect.x), sy = Math.max(0, cropRect.y);
                const sWidth = Math.min(drawingCanvas.width - sx, cropRect.width), sHeight = Math.min(drawingCanvas.height - sy, cropRect.height);
                if (sWidth <= 0 || sHeight <= 0) {
                    clearAllSelections();
                    return showMessage('유효한 자르기 영역이 아닙니다.');
                }
                const croppedImageData = tempCtx.getImageData(sx, sy, sWidth, sHeight);
                
                const cropResultCanvas = document.createElement('canvas');
                cropResultCanvas.width = sWidth;
                cropResultCanvas.height = sHeight;
                cropResultCanvas.getContext('2d').putImageData(croppedImageData, 0, 0);

                const newImg = new Image();
                newImg.onload = () => {
                    layers = [];
                    activeLayerIds = [];
                    originalImage = newImg;
                    initialUploadImage = newImg;
                    scale = Math.min(canvasContainer.clientWidth / originalImage.width, canvasContainer.clientHeight / originalImage.height, 1);
                    clearAllSelections();
                    renderAll();
                    saveState();
                    updateButtonStates();
                    showMessage('이미지를 잘랐습니다.');
                };
                newImg.src = cropResultCanvas.toDataURL();
            }
            
            // --- handleReset 개선: 활성 도구 초기화 추가 ---
            function handleReset() {
                 if (!initialUploadImage) return;
                originalImage = initialUploadImage;
                layers = [];
                activeLayerIds = [];
                scale = Math.min(canvasContainer.clientWidth / originalImage.width, canvasContainer.clientHeight / originalImage.height, 1);
                
                activeTool = null; // Reset the active tool
                
                clearAllSelections();
                renderAll();
                saveState();
                updateButtonStates();
                showMessage('캔버스가 초기화되었습니다.');
            }
            
            function handleDownload(format) {
                if (!drawingCanvas || !originalImage) return;
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = drawingCanvas.width;
                tempCanvas.height = drawingCanvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                
                if(format === 'jpeg'){
                    tempCtx.fillStyle = '#FFFFFF';
                    tempCtx.fillRect(0,0, tempCanvas.width, tempCanvas.height);
                }
                
                tempCtx.drawImage(drawingCanvas, 0, 0);

                if (format === 'pdf') {
                    const { jsPDF } = window.jspdf;
                    const imgData = tempCanvas.toDataURL('image/jpeg', 1.0);
                    const pdf = new jsPDF({
                        orientation: tempCanvas.width > tempCanvas.height ? 'l' : 'p',
                        unit: 'px',
                        format: [tempCanvas.width, tempCanvas.height]
                    });
                    pdf.addImage(imgData, 'JPEG', 0, 0, tempCanvas.width, tempCanvas.height);
                    pdf.save('colored_drawing.pdf');
                } else {
                    const a = document.createElement('a');
                    a.href = tempCanvas.toDataURL(`image/${format}`);
                    a.download = `colored_drawing.${format}`;
                    a.click();
                }
                 showMessage(`${format.toUpperCase()} 파일이 다운로드됩니다!`);
            }
            
            function handleOpacityChange() {
                if (activeLayerIds.length > 0) {
                    const newOpacity = parseFloat(opacitySlider.value);
                    activeLayerIds.forEach(id => {
                        const layer = layers.find(l => l.id === id);
                        if (layer) layer.opacity = newOpacity;
                    });
                    renderDrawingCanvas();
                }
            }

            function handleOpacityChangeEnd() {
                if (activeLayerIds.length > 0) saveState();
            }

            function handleColorPickerInput() {
                updateSwatches();
                if (activeLayerIds.length > 0) {
                    const newColor = colorPicker.value;
                    activeLayerIds.forEach(id => {
                        const layer = layers.find(l => l.id === id);
                        if (layer) layer.color = newColor;
                    });
                    renderDrawingCanvas();
                }
            }

            function handleColorPickerChange() {
                if (activeLayerIds.length > 0) saveState();
            }
            
            function handleBlendModeChange() {
                 if (activeLayerIds.length > 0) {
                    const newBlendMode = blendModeSelect.value;
                    activeLayerIds.forEach(id => {
                        const layer = layers.find(l => l.id === id);
                        if (layer) layer.blendMode = newBlendMode;
                    });
                    renderDrawingCanvas();
                    saveState();
                }
            }

            function handleFeatherChange() {
                if (activeLayerIds.length > 0) {
                    const newFeather = parseFloat(featherSlider.value);
                    activeLayerIds.forEach(id => {
                        const layer = layers.find(l => l.id === id);
                        if (layer) layer.feather = newFeather;
                    });
                    renderDrawingCanvas();
                }
            }

            function handleFeatherChangeEnd() {
                if (activeLayerIds.length > 0) saveState();
            }

            function startSelectionLoop() {
                if (!isDrawing) return;
                const containerRect = canvasContainer.getBoundingClientRect();
                const { x: clientX, y: clientY } = lastClientPos;
                const threshold = 50, scrollSpeed = 15;
                if (clientY < containerRect.top + threshold) canvasContainer.scrollTop -= scrollSpeed;
                else if (clientY > containerRect.bottom - threshold) canvasContainer.scrollTop += scrollSpeed;
                const currentPos = getMousePos({ clientX, clientY });
                const rect = {
                    x: Math.min(currentPos.x, startPos.x), y: Math.min(currentPos.y, startPos.y),
                    width: Math.abs(currentPos.x - startPos.x), height: Math.abs(currentPos.y - startPos.y)
                };
                if (activeTool === 'rectangularSelect') selectionRect = rect;
                else if (activeTool === 'crop') cropRect = rect;
                renderSelectionCanvas();
                animationFrameId = requestAnimationFrame(startSelectionLoop);
            }

            function handleMouseMove(e) {
                if (isDrawing) {
                    lastClientPos = { x: e.clientX, y: e.clientY };
                } else if (activeTool === 'polygonLassoSelect' && isPolygonDrawing && polygonPoints.length > 0) {
                    let pos = getMousePos(e);
                    // Shift key snapping logic
                    if (e.shiftKey) {
                        const lastPoint = polygonPoints[polygonPoints.length - 1];
                        const dx = pos.x - lastPoint.x;
                        const dy = pos.y - lastPoint.y;
                        const angle = Math.atan2(dy, dx);
                        const snappedAngle = Math.round(angle * 4 / Math.PI) * (Math.PI / 4); // Snap to 45-degree increments
                        const distance = Math.hypot(dx, dy);
                        pos = {
                            x: lastPoint.x + Math.cos(snappedAngle) * distance,
                            y: lastPoint.y + Math.sin(snappedAngle) * distance
                        };
                    }
                    polygonPreviewEndPoint = pos;
                    renderSelectionCanvas();
                }
            }

            function handleMouseUp() {
                if (isDrawing) {
                    isDrawing = false;
                    cancelAnimationFrame(animationFrameId);
                    if (activeTool === 'rectangularSelect' && selectionRect && selectionRect.width > 1 && selectionRect.height > 1) {
                        const pixelsToFill = [];
                        const { x, y, width, height } = selectionRect;
                        for (let i = y; i < y + height; i++) {
                            for (let j = x; j < x + width; j++) {
                                pixelsToFill.push({ x: Math.round(j), y: Math.round(i) });
                            }
                        }
                        addNewLayer(pixelsToFill);
                    }
                    updateButtonStates();
                }
            }

            // --- 더블클릭 핸들러 추가 ---
            function handleDoubleClick(e) {
                if (activeTool === 'polygonLassoSelect' && isPolygonDrawing && polygonPoints.length > 0) {
                    e.preventDefault();
                    closeAndFillPolygon();
                }
            }

            function applyZoom(newScale, centerX, centerY) {
                if (!originalImage) return;

                const container = canvasContainer;
                const oldScale = scale;
                
                const imageX = (container.scrollLeft + centerX) / oldScale;
                const imageY = (container.scrollTop + centerY) / oldScale;

                scale = Math.max(0.1, Math.min(newScale, 10)); // Zoom range limit
                
                handleResize();

                const newScrollLeft = (imageX * scale) - centerX;
                const newScrollTop = (imageY * scale) - centerY;

                container.scrollLeft = newScrollLeft;
                container.scrollTop = newScrollTop;
            }

            function handleKeyDown(e) {
                if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                    e.preventDefault();
                    undo();
                } else if ((e.ctrlKey || e.metaKey) && ['=', '+', '-'].includes(e.key)) {
                    e.preventDefault();
                    if (!originalImage) return;
                    const zoomFactor = 0.15;
                    const newScale = e.key === '-' ? scale - zoomFactor : scale + zoomFactor;
                    const centerX = canvasContainer.clientWidth / 2;
                    const centerY = canvasContainer.clientHeight / 2;
                    applyZoom(newScale, centerX, centerY);
                } else if (e.key === 'Escape' && activeTool === 'polygonLassoSelect') {
                    clearAllSelections();
                    showMessage('직선 선택이 취소되었습니다.');
                }
            }

            function handleRotate(degrees) {
                if (!originalImage) return;

                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                tempCanvas.width = drawingCanvas.height;
                tempCanvas.height = drawingCanvas.width;

                tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
                tempCtx.rotate(degrees * Math.PI / 180);
                tempCtx.drawImage(drawingCanvas, -drawingCanvas.width / 2, -drawingCanvas.height / 2);

                const newImg = new Image();
                newImg.onload = () => {
                    layers = [];
                    activeLayerIds = [];
                    originalImage = newImg;
                    initialUploadImage = newImg;
                    scale = Math.min(canvasContainer.clientWidth / originalImage.width, canvasContainer.clientHeight / originalImage.height, 1);
                    clearAllSelections();
                    renderAll();
                    saveState();
                    updateButtonStates();
                    showMessage(`${degrees > 0 ? '오른쪽' : '왼쪽'}으로 회전했습니다.`);
                };
                newImg.src = tempCanvas.toDataURL();
            }
            
            function handleTouchStart(e) {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    pinchStartDistance = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                    lastScale = scale;
                } else {
                    handleDrawStart(e);
                }
            }

            function handleTouchMove(e) {
                 if (e.touches.length === 2 && pinchStartDistance) {
                    e.preventDefault();
                    const currentPinchDistance = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                    const newScale = lastScale * (currentPinchDistance / pinchStartDistance);
                    
                    const rect = canvasContainer.getBoundingClientRect();
                    const centerX = ((e.touches[0].clientX + e.touches[1].clientX) / 2) - rect.left;
                    const centerY = ((e.touches[0].clientY + e.touches[1].clientY) / 2) - rect.top;
                    
                    applyZoom(newScale, centerX, centerY);
                 } else if (e.touches.length === 1) {
                    const event = { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY, touches: e.touches, shiftKey: e.shiftKey };
                    if (isDrawing) {
                        lastClientPos = { x: event.clientX, y: event.clientY };
                    } else if (activeTool === 'polygonLassoSelect' && isPolygonDrawing && polygonPoints.length > 0) {
                        handleMouseMove(event); // Reuse mouse move logic for touch
                    }
                 }
            }
            
            function handleTouchEnd(e) {
                if (pinchStartDistance) {
                    if (e.touches.length < 2) {
                        pinchStartDistance = null;
                        lastScale = scale;
                    }
                } else {
                    handleMouseUp(e); // Reuse mouse up logic
                }
            }


            function startMarchingAnts() {
                if (antsInterval) return;
                antsInterval = setInterval(() => {
                    dashOffset = (dashOffset + 1) % 16;
                    renderSelectionCanvas();
                }, 100);
            }

            function stopMarchingAnts() {
                clearInterval(antsInterval);
                antsInterval = null;
            }

            function init() {
                // Add tool-btn class for easier selection
                [selectLayerBtn, smartFillBtn, rectSelectBtn, polySelectBtn, cropBtn, applyCropBtn, clearSelectionBtn, undoBtn, resetBtn, downloadPngBtn, downloadJpgBtn, downloadPdfBtn, rotateLeftBtn, rotateRightBtn].forEach(btn => btn.classList.add('tool-btn'));
                
                // Event Listeners
                uploadBtn.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', handleFileChange);
                selectLayerBtn.addEventListener('click', () => activateTool('selectLayer'));
                smartFillBtn.addEventListener('click', () => activateTool('smartFill'));
                rectSelectBtn.addEventListener('click', () => activateTool('rectangularSelect'));
                polySelectBtn.addEventListener('click', () => activateTool('polygonLassoSelect'));
                cropBtn.addEventListener('click', () => activateTool('crop'));
                applyCropBtn.addEventListener('click', handleApplyCrop);
                clearSelectionBtn.addEventListener('click', clearAllSelections);
                undoBtn.addEventListener('click', undo);
                resetBtn.addEventListener('click', handleReset);
                downloadPngBtn.addEventListener('click', () => handleDownload('png'));
                downloadJpgBtn.addEventListener('click', () => handleDownload('jpeg'));
                downloadPdfBtn.addEventListener('click', () => handleDownload('pdf'));
                rotateLeftBtn.addEventListener('click', () => handleRotate(-90));
                rotateRightBtn.addEventListener('click', () => handleRotate(90));
                colorPicker.addEventListener('input', handleColorPickerInput);
                colorPicker.addEventListener('change', handleColorPickerChange);
                opacitySlider.addEventListener('input', handleOpacityChange);
                opacitySlider.addEventListener('mouseup', handleOpacityChangeEnd);
                opacitySlider.addEventListener('touchend', handleOpacityChangeEnd);
                blendModeSelect.addEventListener('change', handleBlendModeChange);
                featherSlider.addEventListener('input', handleFeatherChange);
                featherSlider.addEventListener('mouseup', handleFeatherChangeEnd);
                featherSlider.addEventListener('touchend', handleFeatherChangeEnd);
                lineWidthSlider.addEventListener('input', renderSelectionCanvas);
                
                window.addEventListener('resize', handleResize);
                window.addEventListener('keydown', handleKeyDown);

                // Context Menu Events
                canvasContainer.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    if (!originalImage) return;
                    contextMenu.style.left = `${e.clientX}px`;
                    contextMenu.style.top = `${e.clientY}px`;
                    contextMenu.style.display = 'block';
                });
                document.addEventListener('click', (e) => {
                    if (!contextMenu.contains(e.target)) {
                        contextMenu.style.display = 'none';
                    }
                });
                contextDownloadPng.addEventListener('click', () => { handleDownload('png'); contextMenu.style.display = 'none'; });
                contextDownloadJpg.addEventListener('click', () => { handleDownload('jpeg'); contextMenu.style.display = 'none'; });
                contextDownloadPdf.addEventListener('click', () => { handleDownload('pdf'); contextMenu.style.display = 'none'; });
                
                // Mouse Events
                selectionCanvas.addEventListener('mousedown', handleDrawStart);
                selectionCanvas.addEventListener('dblclick', handleDoubleClick);
                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', handleMouseUp);
                
                // Touch Events (Double-tap is handled within handleDrawStart for simplicity)
                canvasContainer.addEventListener('touchstart', handleDrawStart, { passive: false });
                canvasContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
                canvasContainer.addEventListener('touchend', handleTouchEnd);

                // Initial setup
                createSwatches();
                updateButtonStates();
            }

            init();
        });
    </script>
</body>
</html>
